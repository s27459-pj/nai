"""
This type stub file was generated by pyright.
"""

"""The standard AI algorithm of easyAI is Negamax with alpha-beta pruning.
This version does not use recursion. It also does not support transposition
tables, but it does REQUIRE the `tt_entry` method in the game.

It does not make use of 'unmake_move', though having it will not cause a
problem.

It also requires a reverse function: 'ttrestore' that takes the value from
'ttentry' and restores the game state.
"""
INF = ...
IMAGE = ...
MOVE_LIST = ...
CURRENT_MOVE = ...
BEST_MOVE = ...
BEST_SCORE = ...
PLAYER = ...
ALPHA = ...
BETA = ...
DOWN = ...
UP = ...
class StateObject:
    def __init__(self) -> None:
        ...
    
    def prune(self): # -> None:
        ...
    
    def out_of_moves(self): # -> bool:
        """ we are at or past the end of the move list """
        ...
    
    def goto_next_move(self):
        ...
    
    def swap_alpha_beta(self): # -> None:
        ...
    


class StateList:
    def __init__(self, target_depth) -> None:
        ...
    
    def __getitem__(self, key):
        ...
    


def negamax_nr(game, target_depth, scoring, alpha=..., beta=...): # -> float:
    ...

class NonRecursiveNegamax:
    """
    This implements Negamax without recursion. The following example shows
    how to setup the AI and play a Connect Four game:

        >>> from easyAI.games import ConnectFour
        >>> from easyAI import NonRecursiveNegamax, Human_Player, AI_Player
        >>> scoring = lambda game: -100 if game.lose() else 0
        >>> ai_algo = NonRecursiveNegamax(8, scoring) # AI will think 8 turns in advance
        >>> game = ConnectFour([Human_Player(), AI_Player(ai_algo)])
        >>> game.play()

    This algorithm also *REQUIRES* that the game class support the ``ttentry`` and
    ``ttrestore`` methods.

    This algorithm ignores any optional ``unmake_move`` method in the game class.

    This version of Negamax does not support transposition tables.

    Parameters
    -----------

    depth:
      How many moves in advance should the AI think ?
      (2 moves = 1 complete turn)

    scoring:
      A function f(game)-> score. If no scoring is provided
         and the game object has a ``scoring`` method it will be used.

    win_score:
      Score above which the score means a win.

    tt:
      A transposition table (a table storing game states and moves). Currently,
      this parameter is ignored.

    """
    def __init__(self, depth, scoring=..., win_score=..., tt=...) -> None:
        ...
    
    def __call__(self, game):
        """
        Returns the AI's best move given the current state of the game.
        """
        ...
    


